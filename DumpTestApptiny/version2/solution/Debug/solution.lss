
solution.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000134  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00000134  000001a8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .comment      00000030  00000000  00000000  000001a8  2**0
                  CONTENTS, READONLY
  3 .debug_aranges 000000a8  00000000  00000000  000001d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000004d9  00000000  00000000  00000280  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 00000183  00000000  00000000  00000759  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   00000214  00000000  00000000  000008dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000124  00000000  00000000  00000af0  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    0000034f  00000000  00000000  00000c14  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00000127  00000000  00000000  00000f63  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000088  00000000  00000000  0000108a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	10 c0       	rjmp	.+32     	; 0x22 <__ctors_end>
   2:	17 c0       	rjmp	.+46     	; 0x32 <__bad_interrupt>
   4:	17 c0       	rjmp	.+46     	; 0x34 <__vector_2>
   6:	15 c0       	rjmp	.+42     	; 0x32 <__bad_interrupt>
   8:	14 c0       	rjmp	.+40     	; 0x32 <__bad_interrupt>
   a:	13 c0       	rjmp	.+38     	; 0x32 <__bad_interrupt>
   c:	12 c0       	rjmp	.+36     	; 0x32 <__bad_interrupt>
   e:	11 c0       	rjmp	.+34     	; 0x32 <__bad_interrupt>
  10:	10 c0       	rjmp	.+32     	; 0x32 <__bad_interrupt>
  12:	0f c0       	rjmp	.+30     	; 0x32 <__bad_interrupt>
  14:	0e c0       	rjmp	.+28     	; 0x32 <__bad_interrupt>
  16:	0d c0       	rjmp	.+26     	; 0x32 <__bad_interrupt>
  18:	0c c0       	rjmp	.+24     	; 0x32 <__bad_interrupt>
  1a:	0b c0       	rjmp	.+22     	; 0x32 <__bad_interrupt>
  1c:	0a c0       	rjmp	.+20     	; 0x32 <__bad_interrupt>
  1e:	09 c0       	rjmp	.+18     	; 0x32 <__bad_interrupt>
  20:	08 c0       	rjmp	.+16     	; 0x32 <__bad_interrupt>

00000022 <__ctors_end>:
  22:	11 24       	eor	r1, r1
  24:	1f be       	out	0x3f, r1	; 63
  26:	cf e5       	ldi	r28, 0x5F	; 95
  28:	d2 e0       	ldi	r29, 0x02	; 2
  2a:	de bf       	out	0x3e, r29	; 62
  2c:	cd bf       	out	0x3d, r28	; 61
  2e:	13 d0       	rcall	.+38     	; 0x56 <main>
  30:	7f c0       	rjmp	.+254    	; 0x130 <_exit>

00000032 <__bad_interrupt>:
  32:	e6 cf       	rjmp	.-52     	; 0x0 <__vectors>

00000034 <__vector_2>:
#include <avr/power.h>
#include <avr/sleep.h>
#include <avr/interrupt.h>


ISR( PCINT0_vect ){
  34:	1f 92       	push	r1
  36:	0f 92       	push	r0
  38:	0f b6       	in	r0, 0x3f	; 63
  3a:	0f 92       	push	r0
  3c:	11 24       	eor	r1, r1
	// ISR code goes here.	
}
  3e:	0f 90       	pop	r0
  40:	0f be       	out	0x3f, r0	; 63
  42:	0f 90       	pop	r0
  44:	1f 90       	pop	r1
  46:	18 95       	reti

00000048 <_Z15isButtonPressedv>:

bool isButtonPressed()
{
	if ( (PINA&(1<<PWR_READ))   == 0x00 )
  48:	89 b3       	in	r24, 0x19	; 25
  4a:	83 fb       	bst	r24, 3
  4c:	88 27       	eor	r24, r24
  4e:	80 f9       	bld	r24, 0
		return true;
	}
	else{
		return false;
	}
}
  50:	91 e0       	ldi	r25, 0x01	; 1
  52:	89 27       	eor	r24, r25
  54:	08 95       	ret

00000056 <main>:

int main(void)
{
	//init device
	initDevice();
  56:	21 d0       	rcall	.+66     	; 0x9a <_Z10initDevicev>
	
	// battery check code goes here
	
	// powerDown all
	powerDown();
  58:	66 d0       	rcall	.+204    	; 0x126 <_Z9powerDownv>
	
	//plant PCI here
	plantPinChangeInt();	
  5a:	51 d0       	rcall	.+162    	; 0xfe <_Z17plantPinChangeIntv>
	
	//sleep here every time.
	sleepMe();			
  5c:	2e d0       	rcall	.+92     	; 0xba <_Z7sleepMev>
	
    while(1)
    {
		//remove PCINTs.
		removePinChangeInt(  );
  5e:	5a d0       	rcall	.+180    	; 0x114 <_Z18removePinChangeIntv>
		
        //simple delay goes here
        pressWaitDelay();
  60:	3b d0       	rcall	.+118    	; 0xd8 <_Z14pressWaitDelayv>
		
		//simple delay goes here
		pressWaitDelay();
  62:	3a d0       	rcall	.+116    	; 0xd8 <_Z14pressWaitDelayv>
		 
		//simple delay goes here
		pressWaitDelay(); 
  64:	39 d0       	rcall	.+114    	; 0xd8 <_Z14pressWaitDelayv>
		
		//simple delay goes here
		pressWaitDelay();
  66:	38 d0       	rcall	.+112    	; 0xd8 <_Z14pressWaitDelayv>
		
		//simple delay goes here
		pressWaitDelay(); 
  68:	37 d0       	rcall	.+110    	; 0xd8 <_Z14pressWaitDelayv>
		
		//simple delay goes here
		pressWaitDelay();
  6a:	36 d0       	rcall	.+108    	; 0xd8 <_Z14pressWaitDelayv>
        
        // power On
        powerOn();
  6c:	4f d0       	rcall	.+158    	; 0x10c <_Z7powerOnv>
		
		//simple delay goes here
		pressWaitDelay();
  6e:	34 d0       	rcall	.+104    	; 0xd8 <_Z14pressWaitDelayv>
		
		//simple delay goes here
		pressWaitDelay();
  70:	33 d0       	rcall	.+102    	; 0xd8 <_Z14pressWaitDelayv>
		
		//simple delay goes here
		pressWaitDelay();
  72:	32 d0       	rcall	.+100    	; 0xd8 <_Z14pressWaitDelayv>
		
		//simple delay goes here
		pressWaitDelay();
  74:	31 d0       	rcall	.+98     	; 0xd8 <_Z14pressWaitDelayv>
		
		//simple delay goes here
		pressWaitDelay();
  76:	30 d0       	rcall	.+96     	; 0xd8 <_Z14pressWaitDelayv>
		
		//simple delay goes here
		pressWaitDelay();
  78:	2f d0       	rcall	.+94     	; 0xd8 <_Z14pressWaitDelayv>
        
		while (isButtonPressed());
  7a:	e6 df       	rcall	.-52     	; 0x48 <_Z15isButtonPressedv>
  7c:	81 11       	cpse	r24, r1
  7e:	fd cf       	rjmp	.-6      	; 0x7a <main+0x24>
		
		//simple delay goes here
		pressWaitDelay();
  80:	2b d0       	rcall	.+86     	; 0xd8 <_Z14pressWaitDelayv>
		
		//simple delay goes here
		pressWaitDelay();
  82:	2a d0       	rcall	.+84     	; 0xd8 <_Z14pressWaitDelayv>
		
		//simple delay goes here
		pressWaitDelay();
  84:	29 d0       	rcall	.+82     	; 0xd8 <_Z14pressWaitDelayv>
		
		//
        // monitor battery level or just check  battery level here a non blocking api.
		//
		
		if( !isButtonPushedLong() ){
  86:	2f d0       	rcall	.+94     	; 0xe6 <_Z18isButtonPushedLongv>
  88:	88 23       	and	r24, r24
  8a:	49 f3       	breq	.-46     	; 0x5e <main+0x8>
		}
		
		//else goes here out of if else snippet.
		
		// power Down all
		powerDown();
  8c:	4c d0       	rcall	.+152    	; 0x126 <_Z9powerDownv>
		
		//simple delay goes here
		pressWaitDelay();
  8e:	24 d0       	rcall	.+72     	; 0xd8 <_Z14pressWaitDelayv>
		
		//simple delay goes here
		pressWaitDelay();
  90:	23 d0       	rcall	.+70     	; 0xd8 <_Z14pressWaitDelayv>
		
		//simple delay goes here
		pressWaitDelay();
  92:	22 d0       	rcall	.+68     	; 0xd8 <_Z14pressWaitDelayv>
		
		
		//plant PCI here
		plantPinChangeInt();
  94:	34 d0       	rcall	.+104    	; 0xfe <_Z17plantPinChangeIntv>
		
		//sleep here every time.
		sleepMe();		
  96:	11 d0       	rcall	.+34     	; 0xba <_Z7sleepMev>
  98:	e2 cf       	rjmp	.-60     	; 0x5e <main+0x8>

0000009a <_Z10initDevicev>:
#include <avr/sleep.h>
#include <avr/interrupt.h>

void initDevice(){
	// Battery Check and sleep.
	MCUCR = 0x00;		//disable any interrupt source.
  9a:	15 be       	out	0x35, r1	; 53
	sleep_disable();
  9c:	85 b7       	in	r24, 0x35	; 53
  9e:	8f 7d       	andi	r24, 0xDF	; 223
  a0:	85 bf       	out	0x35, r24	; 53
	
	unsigned int uchCount = 0;
	
	sbi(DDRA, LED0);					// set LED0 to output
  a2:	d1 9a       	sbi	0x1a, 1	; 26
	sbi(DDRA, LED1);					// set LED1 to output
  a4:	d2 9a       	sbi	0x1a, 2	; 26
	sbi(DDRA, SHDWN);					// set SHDWN to output
  a6:	d0 9a       	sbi	0x1a, 0	; 26
	cbi(DDRA, PWR);						// set PWR to input.
  a8:	d3 98       	cbi	0x1a, 3	; 26
		
	sbi(PORTA, LED0);
  aa:	d9 9a       	sbi	0x1b, 1	; 27
  ac:	88 ed       	ldi	r24, 0xD8	; 216
  ae:	96 ed       	ldi	r25, 0xD6	; 214
  b0:	01 97       	sbiw	r24, 0x01	; 1
	while ( uchCount < 55000 ){
  b2:	00 97       	sbiw	r24, 0x00	; 0
  b4:	e9 f7       	brne	.-6      	; 0xb0 <_Z10initDevicev+0x16>
		uchCount++;
	}	
	
	cbi(PORTA, LED0);
  b6:	d9 98       	cbi	0x1b, 1	; 27
  b8:	08 95       	ret

000000ba <_Z7sleepMev>:
	return ( (portNumber & (1<<pinNumber) ) >> pinNumber );// will return 0x00 or 0x01;
}

void sleepMe()
{		
	set_sleep_mode( SLEEP_MODE_PWR_DOWN );
  ba:	85 b7       	in	r24, 0x35	; 53
  bc:	87 7e       	andi	r24, 0xE7	; 231
  be:	80 61       	ori	r24, 0x10	; 16
  c0:	85 bf       	out	0x35, r24	; 53
	sleep_enable();
  c2:	85 b7       	in	r24, 0x35	; 53
  c4:	80 62       	ori	r24, 0x20	; 32
  c6:	85 bf       	out	0x35, r24	; 53
	sleep_mode();
  c8:	85 b7       	in	r24, 0x35	; 53
  ca:	80 62       	ori	r24, 0x20	; 32
  cc:	85 bf       	out	0x35, r24	; 53
  ce:	88 95       	sleep
  d0:	85 b7       	in	r24, 0x35	; 53
  d2:	8f 7d       	andi	r24, 0xDF	; 223
  d4:	85 bf       	out	0x35, r24	; 53
  d6:	08 95       	ret

000000d8 <_Z14pressWaitDelayv>:
}

bool pressWaitDelay()
{
  d8:	89 ed       	ldi	r24, 0xD9	; 217
  da:	96 ed       	ldi	r25, 0xD6	; 214
  dc:	01 97       	sbiw	r24, 0x01	; 1
	unsigned int nTimeM = 0;
	
	while (1)
	{
		nTimeM++;
		if (nTimeM > PRESS_WAIT)
  de:	00 97       	sbiw	r24, 0x00	; 0
  e0:	e9 f7       	brne	.-6      	; 0xdc <_Z14pressWaitDelayv+0x4>
			break;
		}
	}
	
	return true;
}
  e2:	81 e0       	ldi	r24, 0x01	; 1
  e4:	08 95       	ret

000000e6 <_Z18isButtonPushedLongv>:
{
	unsigned int nPressCount = 0;
	bool event = false;
	
	//while (digitalRead(PORTA, PWR) == 0x00)
	while ( (PINA&(1<<PWR_READ))   == 0x00)
  e6:	89 ed       	ldi	r24, 0xD9	; 217
  e8:	96 ed       	ldi	r25, 0xD6	; 214
  ea:	03 c0       	rjmp	.+6      	; 0xf2 <_Z18isButtonPushedLongv+0xc>
  ec:	01 97       	sbiw	r24, 0x01	; 1
	{
		nPressCount++;
		if( nPressCount > PRESS_WAIT ){
  ee:	00 97       	sbiw	r24, 0x00	; 0
  f0:	21 f0       	breq	.+8      	; 0xfa <_Z18isButtonPushedLongv+0x14>
{
	unsigned int nPressCount = 0;
	bool event = false;
	
	//while (digitalRead(PORTA, PWR) == 0x00)
	while ( (PINA&(1<<PWR_READ))   == 0x00)
  f2:	cb 9b       	sbis	0x19, 3	; 25
  f4:	fb cf       	rjmp	.-10     	; 0xec <_Z18isButtonPushedLongv+0x6>
}

bool isButtonPushedLong()
{
	unsigned int nPressCount = 0;
	bool event = false;
  f6:	80 e0       	ldi	r24, 0x00	; 0
  f8:	08 95       	ret
	//while (digitalRead(PORTA, PWR) == 0x00)
	while ( (PINA&(1<<PWR_READ))   == 0x00)
	{
		nPressCount++;
		if( nPressCount > PRESS_WAIT ){
			event = true;
  fa:	81 e0       	ldi	r24, 0x01	; 1
			break;
		}
	}
	
	return event;
}
  fc:	08 95       	ret

000000fe <_Z17plantPinChangeIntv>:

void plantPinChangeInt(  )
{
	cli();
  fe:	f8 94       	cli
	sbi(PCMSK0, PCINT3);	// set bit PCINTN on this interrupt.			
 100:	93 9a       	sbi	0x12, 3	; 18
	sbi(GIMSK, PCIE0);      // enable interrupt pin change.
 102:	8b b7       	in	r24, 0x3b	; 59
 104:	80 61       	ori	r24, 0x10	; 16
 106:	8b bf       	out	0x3b, r24	; 59
	sei();
 108:	78 94       	sei
 10a:	08 95       	ret

0000010c <_Z7powerOnv>:
}

void powerOn()
{	
	sbi( PORTA, LED1);
 10c:	da 9a       	sbi	0x1b, 2	; 27
	sbi( PORTA, LED0);
 10e:	d9 9a       	sbi	0x1b, 1	; 27
	sbi( PORTA, SHDWN);	
 110:	d8 9a       	sbi	0x1b, 0	; 27
 112:	08 95       	ret

00000114 <_Z18removePinChangeIntv>:
}

void removePinChangeInt( )
{
	cli();
 114:	f8 94       	cli
	cbi(SREG, SREG_I);		// clear global intterupt. alternative code line cli();
 116:	8f b7       	in	r24, 0x3f	; 63
 118:	8f 77       	andi	r24, 0x7F	; 127
 11a:	8f bf       	out	0x3f, r24	; 63
	cbi(GIMSK, PCIE0);      // enable interrupt pin change.	
 11c:	8b b7       	in	r24, 0x3b	; 59
 11e:	8f 7e       	andi	r24, 0xEF	; 239
 120:	8b bf       	out	0x3b, r24	; 59
	cbi(PCMSK0, PCINT3);	// set bit PCINTN on this interrupt.
 122:	93 98       	cbi	0x12, 3	; 18
 124:	08 95       	ret

00000126 <_Z9powerDownv>:
	
}

void powerDown()
{
	cbi( PORTA, LED1);
 126:	da 98       	cbi	0x1b, 2	; 27
	cbi( PORTA, LED0);
 128:	d9 98       	cbi	0x1b, 1	; 27
	cbi( PORTA, SHDWN);
 12a:	d8 98       	cbi	0x1b, 0	; 27
	
	cbi(ADCSRA,ADEN);                              //switch Analog to Digital Converter OFF
 12c:	37 98       	cbi	0x06, 7	; 6
 12e:	08 95       	ret

00000130 <_exit>:
 130:	f8 94       	cli

00000132 <__stop_program>:
 132:	ff cf       	rjmp	.-2      	; 0x132 <__stop_program>
